\documentclass{article}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
\usepackage{amsmath}
\usepackage{ifthen}
\usepackage{amsfonts}
\usepackage{dsfont}
\usepackage{boxedminipage}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage[toc,page]{appendix}

\newcommand{\R}{\ensuremath{\mathds{R}}}
\newcommand{\C}{\ensuremath{\mathds{C}}}
\newcommand{\Q}{\ensuremath{\mathds{Q}}}
\newcommand{\N}{\ensuremath{\mathcal{N}}}
\newcommand{\Z}{\ensuremath{\mathds{Z}}}
\newcommand{\D}{\ensuremath{\mathds{D}}}
\newcommand{\W}{\ensuremath{\mathds{W}}}
\newcommand{\B}{\ensuremath{\mathds{B}}}
\newcommand{\mS}{\ensuremath{\mathds{S}}}
\newcommand{\I}{\ensuremath{I}}
\newcommand{\1}{\ensuremath{\mathds{1}}}
\newcommand{\SO}{\ensuremath{\mathsf{SO}}}
\newcommand{\Sp}{\ensuremath{\mathsf{Sp}}}
\newcommand{\s}{\ensuremath{\mathfrak{s}}}
\newcommand{\n}{\ensuremath{\mathfrak{n}}}
\newcommand{\Ocplx}{\ensuremath{\mathcal{O}}}
\newcommand{\0}{\ensuremath{0}}
\newcommand{\cset}[1]{\mathcal{#1}}

\newcommand{\softname}{SSA Toolbox}

\newcommand{\KLD}{D_{\text{KL}}}
%\DeclareMathOperator*{\KLD}{KL}

\DeclareMathOperator*{\diag}{diag}
\DeclareMathOperator*{\E}{\mathbb{E}}
\DeclareMathOperator*{\sign}{sign}
\DeclareMathOperator*{\trace}{tr}
\DeclareMathOperator*{\var}{var}
\DeclareMathOperator*{\cov}{cov}
\DeclareMathOperator*{\expm}{expm}
\DeclareMathOperator*{\myspan}{span}

\setcounter{tocdepth}{1} 

\begin{document}

\title{SSA Toolbox \input version.tex --- Manual}
\author{Jan Saputra M\"uller, Paul von B\"unau, \\ Frank C.~Meinecke, Franz J.~Kir\'{a}ly, Klaus-Robert M\"uller}

\maketitle

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Overview}

This is the manual for the SSA Toolbox, an efficient open-source implementation of the 
Stationary Subspace Analysis~\cite{PRL:SSA:2009} algorithm. Stationary Subspace Analysis (SSA)
is a general purpose algorithm for the explorative analysis of non-stationary data, i.e.~data
whose statistical properties change over time. SSA can helps to detect, characterize and 
visualize temporal changes in complex high-dimensional data sets.

The SSA Toolbox is written entirely in Java and is thus platform-independent. It has been tested
successfuly under Windows, Linux and MacOS. The SSA Toolbox comes with a state-of-the-art native 
Linear Algebra library (BLAS / LAPACK) that is invoked if the operating system supports 
it. If not, a purely Java-based library, COLT, will be used that ensures maximum platform-independence. 
Data and results can imported and exported as comma-separated values (CSV) files, the fail-safe 
format of last resort, and through Matlab's proprietory mat files, a de-facto standard in the 
Machine Learning community.

The source code of the SSA Toolbox is fully documented (using the JavaDoc standard) and accompanied
by a set of unit tests written in JUnit. The latest version is always available from 
github\footnote{See \url{http://https://github.com/paulbuenau/SSA-Toolbox}}, a hosting service for
the git versioning system. Section~\ref{sec:dev} contains further information for developers, 
including a high-level overview of the class structure.
 
There are three ways to use the SSA Toolbox
\begin{enumerate}
	\item As a standalone application with a graphical user interface. 
	 
	\item From within Matlab, using the wrapper script \texttt{ssa.m}. 

	\item As a Java library, from your own application.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation and Running}
\label{sec:install_run}

\paragraph{Obtaining the latest SSA~Toolbox}

The latest version of the SSA~Toolbox is available from the offical SSA homepage: 
\begin{center}
	\url{http://www.stationary-subspace-analysis.org/toolbox}
\end{center}
There you can also find pointers to further references, example data and a link 
to the SSA mailing list. 

\paragraph{Platforms}

The SSA~Toolbox is written in the platform-independent Java programming language; 
platform-specific numerical libraries\footnote{BLAS+LAPACK provided through
jblas (see \url{http://www.jblas.org}).} are included for several target architectures. 
The SSA~Toolbox requires the Java Runtime Environment\footnote{See 
\url{http://www.java.com/getjava}} version 1.5 or later. Most operating systems
have a Java Runtime Environment pre-installed, you might be able to find out 
the version by typing \texttt{java -version} on the command line. The SSA~Toolbox has 
been tested on the following platforms.
\begin{itemize}
	\item Microsoft Windows (32 and 64 bit)
	\item Linux (32 and 64 bit)
	\item Mac OS X (32 and 64 bit)
\end{itemize}

\paragraph{Installation and Running}

The SSA~Toolbox comes as a single \texttt{.zip} or \texttt{.tar.gz} archive. 
After unpacking, you can start the SSA~Toolbox by opening the file \texttt{ssa.jar}
with the default method of your operating system, e.g.~by double-clicking on it under 
Microsoft Windows, OS X and some Linux distributions.

You can also manually invoke the SSA~Toolbox by typing
\begin{center}
  \texttt{java -jar ssa.jar}
\end{center}
on the command line of your operating system.

In some cases, if you want to run SSA on very large data sets, it might be necessary to start the toolbox
with a higher amount of Java heap space (in those cases the SSA toolbox will inform you
about this issue). There is a section in the Frequently Asked Questions which explains how to do that
(see Section~\ref{sec:faq}).

If you want to use the SSA~Toolbox directly 
from Matlab, you can use the wrapper script \texttt{ssa.m}. Type \texttt{help ssa} on 
the Matlab command line to find out about the format of its input and output parameters. 
Note that if you invoke the SSA Toolbox from within Matlab, it will use its
internal JVM unless you specify an external JVM, e.g. using the environment
variable \texttt{MATLAB\_JAVA} under Linux.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Stationary Subspace Analysis in Brief}

Stationary Subspace Analysis \cite{PRL:SSA:2009} factorizes a multivariate time-series 
into its stationary and non-stationary components. That is, we assume that the data 
generating system consists of $d$ stationary source signals 
${\mathbf s^\s}(t) = [s_1(t), \dots, s_d(t)]^\top$ and $D-d$ non-stationary source signals
${\mathbf s^\n}(t) = [s_{d+1}(t), \dots, s_D(t)]^\top$ and that the observed signals 
$x(t)$ are a linear superposition of these sources,
\begin{equation}
  {\mathbf x}(t) = A {\mathbf s}(t) = 
    \begin{bmatrix} A^{\s} & A^{\n} \end{bmatrix}
    \begin{bmatrix} {\mathbf s^{\s}}(t) \\ {\mathbf s^{\n}}(t) \end{bmatrix}
\label{eq:mixing_model}
\end{equation}
where $A$ is an invertible matrix. Note that we do \textit{not} assume that 
the sources ${\mathbf s}(t)$ are independent. We refer to the spaces spannend 
by the columns of $A^{\s}$ and $A^{\n}$ as the stationary ($\s$-) and 
non-stationary ($\n$-) space respectively.  

The SSA algorithm factorizes the observed signals $x(t)$ according to
Equation~\ref{eq:mixing_model}, i.e.~it finds a linear transformation
\begin{equation}
\label{eq:est_demixing}
  \hat{A}^{-1} = \begin{bmatrix} \hat{P}^{\s} \\ \hat{P}^{\n} \end{bmatrix}
\end{equation}
that separates the \s-sources from the \n-sources. The inverse of the estimated 
demixing matrix $\hat{A}^{-1}$ is the estimated mixing matrix, 
\begin{equation}
\label{eq:est_mixing}
 \hat{A} = \begin{bmatrix} \hat{A}^{\s} & \hat{A}^{\n} \end{bmatrix}, 
\end{equation}
and the estimated stationary and non-stationary sources are thus given by
\begin{align}
\label{eq:est_s_sources}
  \hat{\mathbf s}^{\s}(t) & = \hat{P}^{\s} {\mathbf x}(t) \\
\label{eq:est_n_sources}
  \hat{\mathbf s}^{\n}(t) & = \hat{P}^{\n} {\mathbf x}(t) 
\end{align}
respectively.
Note that only the $\s$-projection and the $\n$-space are uniquely identifiable.
$\hat P^{\n}$ is chosen such that it is orthogonal to $\hat P^{\s}$ and 
$\hat A^{\s}$ is orthogonal to $\hat A^{\n}$.

The SSA Toolbox allows for input and output in (time $\times$ channel) and 
(channel $\times$ time) format. Note that the above definitions of sources, 
projections and basis correspond to the (channel $\times$ time) format.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Input, Output and Parameters}

The input to the SSA Toolbox consists of
\begin{itemize}
 \item Data: the time series $x(t)$, either as $(\text{channels} \times \text{time})$ or 
				$(\text{channels} \times \text{time})$.

 \item Segmentation of the time series $x(t)$ into epochs, either
	\begin{itemize}
	  \item equally-sized, where the number of epochs is supplied by the user; or 

		\item equally-sized, where the number of epochs is set automatically by a heuristic; 

	  \item according to a user-supplied custom epoch definition. 
	\end{itemize}

 \item Parameters to the SSA Algorithm (see Section~\ref{sec:params}).
\end{itemize}

The parameters are set via the graphical user interface. The time series 
$x(t)$ and a custom epoch definition can be loaded from comma-separated values
(CSV) and Matlab (.mat) files.

\subsection{Comma-Separated-Values File Format}
\label{sec:csv_input}

Comma Separated Values (CSV) files are human-readable text files for storing tabular data. 
The columns are separated by commas and each line of the file corresponds to a row. 
Lines starting with a hash (\texttt{\#}) are ignored. If the data has more rows than columns,
then each row will be interpreted as a time point and each column as a channel. Otherwise,
the format is assumed to be $(\text{channels} \times \text{time})$. See 
Figure~\ref{fig:ex_timeseries} for an example time series file. 

\begin{figure}[h]
\centering
\begin{boxedminipage}{10cm}
\begin{verbatim}
# 2ch recording VPzj Oct 30th
-0.18671,0.11393
0.72579,1.0668
-0.58832,0.059281
2.1832,-0.095648
-0.1364,-0.83235
...
\end{verbatim}
\end{boxedminipage}
\caption{
The first five time points of a timeseries in CSV format with two channels. 
The first line is a comment for documentation purposes.
\label{fig:ex_timeseries}
}
\end{figure}

A custom segmentation of the time series into epochs can be specified by means of 
a separate CSV file, which must have the same number of rows as the time series 
and one column. The entries correspond to the index (starting with 1) of the 
epoch that a time point belongs to. Figure~\ref{fig:ex_segmentation} shows 
an example CSV file for a segmentation of the time series into custom epochs. 

\begin{figure}[h]
\centering
\begin{boxedminipage}{10cm}
\begin{verbatim}
# Epochs for recording VPzj Oct 30th
1
1
1
2
2
...
\end{verbatim}
\end{boxedminipage}
\caption{
Custom epoch definition for the first five time points of the time series shown in Figure~\ref{fig:ex_timeseries}. 
The first three time points belong to the same epoch and the last two time points form the second epoch.
\label{fig:ex_segmentation}
}
\end{figure}

\subsection{Matlab File Format}

In the Matlab file format, the time series must be contained in a variable
called \texttt{X}. If \texttt{X} has more rows than columns, then each row
will be interpreted as a time point and each column as a channel. Otherwise,
the format is assumed to be $(\text{channels} \times \text{time})$. 

\begin{figure}[h]
\centering
\begin{boxedminipage}{10cm}
\begin{verbatim}
>> X

X =

   -0.4326   -0.1867
   -1.6656    0.7258
    0.1253   -0.5883
    0.2877    2.1832
   -1.1465   -0.1364
    ...
\end{verbatim}
\end{boxedminipage}
\caption{Timeseries in Matlab with two channels and five time points.
\label{fig:ex_matlabts}
}
\end{figure}

If \texttt{X} is a cell array, then the elements
are interpreted as epochs where each epoch must have the same number 
of channels, Figure~\ref{fig:ex_matlabsegs} shows
an example.

\begin{figure}[h]
\centering
\begin{boxedminipage}{10cm}
\begin{verbatim}
>> X

X = 

    [100x2 double]    [100x2 double]    [80x2 double]
\end{verbatim}
\end{boxedminipage}
\caption{Timeseries in Matlab with custom epoch definition. The time series is split
into three epochs where the first two epochs contain 100 samples each and the third
epoch consists of 80 samples.
\label{fig:ex_matlabsegs}
}
\end{figure}

\FloatBarrier

\subsection{Parameters of SSA}
\label{sec:params}

The SSA algorithm has the following parameters which can be set via the graphical 
user interface.

\paragraph{Number of stationary sources} The number of stationary sources $d$ to be 
found in the time series. Depending on $d$, the algorithm needs a certain minimum number 
of distinct epochs, see next paragraph. A warning message will be issued
if this condition is violated.

\paragraph{Number of restarts} The number of times the optimization procedure
should be repeated with different random initialization in order to avoid local minima.
The final result is the decomposition which attained the smallest objective function
value.

\paragraph{Number of equally-sized epochs} The number of equally sized epochs $N$ that 
the time series should be split into, if the user did not supply a custom segmentation.
The minimum number of epochs required to avoid spurious
stationary directions depends on the number of stationary sources $d$, see next paragraph. 

\paragraph{Which moments of the sources should be considered} Depending on the application domain, 
changes in mean or covariance matrix either do not occur or are not relevant. The user can therefore 
select whether non-stationarities in the mean, covariance matrix or both should be considered. 
The default is that both moments are taken into account.

\subsubsection*{Determinacy of the solution}
\label{sec:determinacy}

If the number of epochs $N$ is too small in relation to the number of 
non-stationary sources $D-d$, there may exist spurious stationary components that render
the solution non-identifiable, i.e. components which appear stationary on the
limited amount of observed data but which are in fact non-stationary.
Informally speaking, spurious stationary components occur when the amount of 
observed variation in the distributions (i.e. the number of distinct epochs)
 is insufficient to eliminate seemingly stationary directions in the non-stationary subspace. 
For example, if you think of two covariance matrices $\Sigma_1, \Sigma_2 \in \R^{2 \times 2}$ in two-dimension, 
then one can always find a one-dimensional subspace on which the projected variances 
agree, unless $\Sigma_1 - \Sigma_2$ has an indefinite spectrum (i.e.~the contour plot
of one covariance matrix is strictly contained in the other). 

It can be shown \cite{PRL:SSA:2009} that there exist no spurious stationary directions
if the number of epochs $N$ is at least 
\begin{equation*}
	N > \frac{D-d}{2} + 2.
\end{equation*}
When only changes in one moment are considered, we need more epochs, namely
\begin{equation*}
	N > D-d + 1 .
\end{equation*}
The SSA~Toolbox issues a warning if these conditions are violated.
In practice, if there is enough data, it is advisable to use more epochs than the minimum
indicated by this bound. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output}

The result of the SSA algorithm is an estimated demixing matrix $\hat{A}^{-1}$
(see Equation~\ref{eq:est_demixing}). From this, the following output
is generated by the SSA~Toolbox (assuming the output format $\text{channels} \times \text{time}$):
\begin{itemize}
	\item the estimated projection to the stationary sources $\hat{P}^\s \in \R^{d \times D}$ 
						
	\item the estimated projection to the non-stationary sources $\hat{P}^\n \in \R^{ (D-d) \times D}$ 

	\item the estimated basis of the stationary subspace $\hat{A}^\s \in \R^{D \times d}$
	
	\item the estimated basis of the non-stationary subspace $\hat{A}^\n \in \R^{D \times (D-d)}$

	\item the estimated stationary sources $\hat{s}^\s(t) = \hat{P}^\s {x}(t)$, 
	
	\item the estimated non-stationary sources $\hat{s}^\n(t) = \hat{P}^\n {x}(t) $
	
\end{itemize}
These six matrices resp.~time series can either be saved in individual CSV files 
(see Section~\ref{sec:csv_input} for a general description of the format) or to a single
Matlab file (.mat). 

\subsection{Matlab File Format}

The output of the SSA Toolbox can be written to a single Matlab file which contains
a structure \texttt{ssa\_results} where the attributes correspond to the six outputs. 
See Figure~\ref{fig:ex_matlab_res} for an example.

\begin{figure}[h]
\centering
\begin{boxedminipage}{12cm}
\begin{verbatim}
>> ssa_results = 

         Ps: [3x6 double]
         Pn: [3x6 double]
         As: [6x3 double]
         An: [6x3 double]
      s_src: [3x10000 double]
      n_src: [3x10000 double]
     parameters: [1x1 struct]
    description: 'SSA results (Thu Jun 10 12:58:23 CEST 2010)'
\end{verbatim}
\end{boxedminipage}
\caption{
Matlab result structure of the SSA Toolbox. Five dimensional data (500 samples) 
are decomposed into $d = 3$ stationary sources and $D-d = 2$ non-stationary sources.
\label{fig:ex_matlab_res}
}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FloatBarrier % Flush all figures, we don't want the file format examples below.

\section{Examples and Toy Data}

The SSA Toolbox comes with an example data set in Matlab and CSV format (\texttt{example\_data.csv} and \texttt{example\_data.mat}), a Matlab script to generate synthetic data (\texttt{ssa\_toydata.m}), and a self-contained 
Matlab demonstration (\texttt{ssa\_demo.m}). In the 
following sections, we describe each of these files.

\subsection{Example Data}

The example data sets in the directory \texttt{example\_data} were generated using the Matlab 
script \texttt{ssa\_toydata.m} using the command-line
\begin{center}
	\texttt{[X, A] = ssa\_toydata(10, 2, 2, 'mean\_nonstat', 0.5)}; 
\end{center}
The dataset consists of ten epochs (each 500 samples); it has two stationary and two non-stationary 
sources. The Matlab file \texttt{example\_data.mat} also contains the true mixing matrix \texttt{A} 
so that you can assess the quality of the found solution using the subspace error between the true
and the estimated basis of the non-stationary spaces as follows:
\begin{center}
	\texttt{subspace\_error(ssa\_results.An, A(:,3:4))}  
\end{center}
A description of this error measure can be found in Appendix~\ref{app:error_measure}. The comma-separated 
values file \texttt{example\_data.csv} contains the same data as the Matlab file. Further details about 
the toy data generation can be found in the next section. 

\subsection{Toy Data Generation}

The Matlab script \texttt{ssa\_toydata.m} generates synthetic datasets according to the SSA mixing 
model. A documentation of the parameters of this function is available from the Matlab help, in this 
section we describe how the data is generated. 

Let $X_1, \ldots, X_n$ be random variables modeling the distribution of the data in each of 
the $n$ epochs. According to the SSA mixing model (Equation~\ref{eq:mixing_model}), each 
epoch is a linear mixture of $d$ stationary and $D-d$ non-stationary sources, 
\begin{align*}
	X_i = A \begin{bmatrix} X^\s \\ X^\n_i \end{bmatrix}
\end{align*}
where $A$ is the mixing matrix and $X^\s$ and $X^\n_i$ are random variables representing 
the \s- and the \n-sources in the $i$-th epoch respectively. The entries of $A$ are chosen 
uniformly at random from $[-0.5, 0.5]$ and its columns are normalized to one. The distribution
of the \s-sources is the same over all epochs, 
\begin{align*}
	X^\s \sim \N(0,I), 
\end{align*}
and the \n-sources are correlated with the \s-sources, 
\begin{align*}
	X^\n_i = C_i X^\s + Y^\n_i,  
\end{align*}
where $C_i$ is $(D-d \times d)$-matrix and $Y^\n_i \sim \N(\mu_i, \Sigma_i)$ is a
random variable corresponding to the conditional $X^\n_i | X^s$. The covariance 
matrix $\Sigma_i$ is generated as, 
\begin{align*}
	\Sigma_i = B^\n_i \Lambda_i (B^\n_i)^\top,
\end{align*}
where $B^\n_i$ is a random orthogonal matrix and $\Lambda_i$ is a diagonal matrix of 
the eigenvalues $\lambda_1, \ldots, \lambda_{D-d}$. Each eigenvalue is drawn uniformly
at random, either from the interval $[v_\text{min}, v_\text{max}]$ (with probability $p$) 
or from the interval $[1/v_\text{max}, 1/v_\text{min}]$ (with probability $1-p$), where 
$1 < v_\text{min} < v_\text{max}$. That is, each eigenvalue $\lambda_i$ is either larger 
or smaller than one, but by the same ratio. For each epoch, the canonical 
correlation $\rho_i$ is drawn uniformly at random from $[\rho_\text{min}, \rho_\text{max}]$, 
which determines the scaling of the rows of $C_i$, 
\begin{align*}
	C_i = B C' (B^\n_i)^\top, 
\end{align*}
where $B$ is a random orthogonal matrix and $C'$ is a $(D-d \times d)$-matrix with 
non-zero entries only on the diagonal, 
\begin{align*}
	(C')_{jj} = \sqrt{ \frac{\lambda_{jj}}{\frac{1}{\rho_i^2 } - 1}} . 
\end{align*}
This ensures that the canonical correlation is $\rho_i$ for all principal vectors. 
Thus the covariance matrix of the sources in the $i$-th epoch is given by, 
\begin{align*}
	\cov \left(   
		\begin{bmatrix} X^\s \\ X^\n_i
		\end{bmatrix} 
	\right) = 
	\begin{bmatrix}
		I & C^\top_i \\
		C_i & C_i  C^\top_i + \Sigma_i 
	\end{bmatrix} .
\end{align*}
The strength of the non-stationarity in the mean of the \n-sources is chosen relative to the 
total non-stationarity $\tilde{\sigma}$ in the covariance matrix which we measure as,
\begin{align*}
	\tilde{\sigma} = \sum_{i=1}^n \sum_{j=1}^{D-d} \left|\log \left[ (\Lambda_i)_{jj} \right]\right| .
\end{align*}
Similarly, we quantify the total non-stationarity in the mean $\tilde{\mu}$ as, 
\begin{align*}
	\tilde{\mu} = \sum_{i=1}^n \| \mu_i \|^2 . 
\end{align*}
Thus we first choose a random set of squared norms $m_1, \ldots, m_n$ such that 
$\sum_{i=1}^n m_i = \tilde{\sigma} = \tilde{\mu}$, and then a set of mean vectors with random entries 
drawn uniformly from $[-0.5, 0.5]$ which we rescale such that $\| \mu_i \|^2 = m_i$. 

\subsection{Matlab Demonstration}
\begin{figure}[h]
\begin{center}
	\includegraphics[angle=90,width=10cm]{ssa_example.pdf}
	\caption{\label{fig:matlab_example}
		Output of the Matlab example \texttt{ssa\_demo.m}} 
\end{center}
The plot generated by the example script is shown in Figure~\ref{fig:matlab_example}. The top panel
shows the two dimensional input time series $x(t)$. Both dimensions (or variables, channels) appear
non-stationary. The vertical red lines indicate how the time series is segmented into four epochs. 
In the middle row, we see the result of applying SSA: for every epoch, the scatter plot shows
the distribution of the estimated stationary source (vertical axis) vs.~the estimated non-stationary 
source (horizontal axis). We can see that the mean and the variance projected to the vertical axis
is constant over the epochs, whereas both change significantly for the estimated non-stationary source. 
The bottom panel shows the time courses for the estimated stationary (top) and the estimated non-stationary 
(bottom) source. 
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\FloatBarrier

\section{Frequently Asked Questions}
\label{sec:faq}

\paragraph{When should I use SSA?} 
SSA can be applied whenever a multivariate dataset, that has a temporal structure is conceivable 
generated as a mixture of stationary and non-stationary components, where the non-stationary 
effects are visible in changes of the mean and covariance matrix. 

\paragraph{Can I use SSA on a univariate time series?} No. 

\paragraph{How do I determine the number of stationary sources?} To date, there exists no automatic
selection procedure. In practice, one can apply SSA for several numbers of stationary sources and inspect
the result, e.g.~visually or using appropriate statistical hypothesis tests.

\paragraph{Why is it not possible to identify the non-stationary sources and what does this mean?} 
The true non-stationary sources cannot be identified because adding stationary components to a 
non-stationary time series leaves it non-stationary. This makes the estimated non-stationary sources 
arbitrary. It is therefore not possible to recover the true non-stationary sources from the mixture. 
	
\paragraph{Why is it not possible to identify the stationary subspace and what does this mean?} The basis
of the stationary subspace cannot be identified because we cannot estimate the non-stationary sources, which
are dual to the basis of the stationary subspace. If we could identify the stationary subspace, then we could
find the non-stationary sources by projecting orthogonal to it.

\paragraph{I would like to use the Toolbox from Python/Octave/or any other environment, is this possible?} 
The SSA Toolbox can be used directly from any environment that can invoke Java code, such as 
e.g.~Matlab. Based on the command-line interface, future releases will include wrappers for R and Python. 

\paragraph{Can I get a $p$-value for my result?} So far there is no method to establish the 
significance of the SSA solution. However, one could use a test for stationarity on the
extracted stationary sources to verify the solution, and report the corresponding $p$-values.

\paragraph{The toolbox says that there is not enough Java heap space. How can I solve this issue?}
You have to increase the Java heap space. If you are using the standalone version of the toolbox, you can
do this by running it from the command line like this:
\begin{center}
\texttt{java -Xmx512M -jar ssa.jar}
\end{center}
This would set the Java heap space to \texttt{512M}. Of course, you can replace \texttt{512M} with your
desired size.

If you are using the toolbox from within Matlab, you have to increase the Java heap space which Matlab uses.
The following website explains how to do that:
\begin{center}
    \url{http://www.mathworks.com/support/solutions/en/data/1-18I2C}
\end{center}
In Matlab 2010a and later, this can be easily done from Matlab's preferences dialog.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Developers}
\label{sec:dev}

This section contains some information about the technical structure of the SSA Toolbox
that is helpful for developers who want to extend it or use parts in other projects. The 
source code distribution of the SSA Toolbox is available from the project 
web site (see Section~\ref{sec:install_run}) and from github, a public git repository 
server, which is the primary location of the source code:
\begin{center}
	\texttt{https://github.com/paulbuenau/SSA-Toolbox}
\end{center}
On github you will always find the latest, probably unreleased version of the SSA Toolbox.

%%%%%%%%%%%%%%%%%
\subsection*{Example}

The code of the SSA Toolbox can be used as a library from other applications. Below you can can find a 
simple example which shows how to load data, parametrize the SSA algorithm, apply it and save the
results to a file.
 
\bigskip

\begin{boxedminipage}{12cm}
\small
\begin{verbatim}
public class SSAJavaExample
{
    public static void main(String args[])
    {
        // create a console logger for writing log messages
        ssatoolbox.ConsoleLogger cl = new ssatoolbox.ConsoleLogger();

        // create instance of SSA main class.
        ssatoolbox.Main ssaMain = new ssatoolbox.Main(false, cl);

        // load data from CSV-file
        ssaMain.loadTimeseries(new java.io.File("data.csv"));

        // set SSA parameters 
        ssaMain.parameters.setNumberOfStationarySources(3);

        // set epochization type
        ssaMain.data.setEpochType(
        	ssatoolbox.Data.EPOCHS_EQUALLY_HEURISTIC);

        // Run SSA (*not* using a separate thread!)
        ssaMain.runSSA(false);

        // save stationary sources
        ssaMain.saveStationarySourcesCSV(
        		new java.io.File("stationary.csv"));

        // save non-stationary sources
        ssaMain.saveNonstationarySourcesCSV(
        	new java.io.File("non-stationary.csv"));
    }
}
\end{verbatim}
\end{boxedminipage}


%%%%%%%%%%%%%%%%%
\subsection*{Class Structure}

The SSA Toolbox consists of the classes \texttt{SSA}, \texttt{SSAParameters}, \texttt{Data}, \texttt{Results}, \texttt{MathFunctions}, 
\texttt{GUI}, \texttt{Main}, \texttt{SSAMatrix}.

\paragraph{SSA} 

This class implements the SSA algorithm. The main-part of the implementation is in the method \texttt{optimizeOnce}, which does
the conjugate gradient descent. The calculation of the objective function and its gradient is done in the method \texttt{objectiveFunction}.
Apart from that, the class \texttt{SSA} is responsible for checking our determinacy bounds and has to throw an exception if they are violated.

\paragraph{SSAParameters}

The class \texttt{SSAParameters} stores the parameters, such as the assumed number of stationary sources, the number of restarts for the optimization and
whether to use means/covariance matrices. It is responsible to check whether the entered parameters are valid and has to throw an exception otherwise.

\paragraph{Data}

The class \texttt{Data} stores our time series and does the epochization (equally sized epochs or custom epochization). It has to check whether the
epochization is valid (and possible) and has to throw an exception otherwise.

\paragraph{Results}

This class stores the results of the SSA algorithm.

\paragraph{MathFunctions}

This class contains auxilliary functions.

\paragraph{GUI}

This class is responsible for the GUI of the standalone-version of the toolbox. It implements the interface \texttt{Logger}.

\paragraph{Main}

This is the main class of the standalone-version of the toolbox.

\paragraph{SSAMatrix}

\texttt{SSAMatrix} is a wrapper class for different matrix libraries. All matrices in the toolbox are instances of this class. It passes the
matrix operations to the currently used matrix library.

\paragraph{Logger}

This is an interface for logging. It contains only one method, which has to be implemented by all implementing classes: \texttt{appendToLog}.

\paragraph{ConsoleLogger}

This class implements the interface \texttt{Logger}. It writes all messages which are passed to the method
\texttt{appendToLog} directly to the console (needed for the matlab-wrapper).

%%%%%%%%%%%%%%%%%
\subsection*{External Dependencies}

The toolbox needs \texttt{JMatIO} (for Matlab files). The class \texttt{SSAMatrix} uses the matrix library \texttt{Colt} or \texttt{jBlas}, depending on which library
is currently selected.

%%%%%%%%%%%%%%%%%
\subsection*{Unit Tests}
The unit tests are realized using \texttt{JUnit} and can be found in the subdirectory \texttt{tests} of the repository.
There are tests for the classes \texttt{Data} and \texttt{SSA}.

\subsubsection*{Tests for the Data class}

\paragraph{\texttt{testSetNumberOfEqualSizeEpochs()}}

This test checks whether an exception is thrown if we have less data points than epochs (in case of equally sized epochs).

\paragraph{\texttt{testSetCustomEpochDefinition()}}

This test checks whether an exception is thrown if we have less data points than epochs (in case of a custom epoch definition).

\subsubsection*{Tests for the SSA class}

\paragraph{\texttt{testOptimizeMeanCov()}}

This test checks whether an exception is thrown if the determinacy bound is violated (when using both means and covariance matrices).

\paragraph{\texttt{testOptimizeMean()}}

This test checks whether an exception is thrown if the determinacy bound is violated (when using means only).

\paragraph{\texttt{testOptimizeCovariance()}}

This test checks whether an exception is thrown if the determinacy bound is violated (when using covariance matrices only).

\paragraph{\texttt{testOptimize()}}

This function contains a simple test which checks
if the SSA optimization works correctly by running the optimization on a very simple data set. This data set is $2$-dimensional, where
the first dimension is stationary and the second one is non-stationary (this means the mixing matrix to be estimated is the identity matrix).
For checking the solution of the optimization, the angle between the estimated stationary projection direction and the correct one
$\begin{pmatrix} 1 \\ 0\end{pmatrix}$ is considered. The same is done with the estimated basis vector of the non-stationary subspace,
where the correct direction is $\begin{pmatrix} 0 \\ 1\end{pmatrix}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contact and Support}

If you have any question, bug report or want to discuss the application of SSA
to a specific problem, please join the SSA mailing list:
\begin{center}
        \url{http://groups.google.com/group/ssa-list}
\end{center}
You can find further
information on the official SSA homepage: 
\begin{center}
	\url{http://www.stationary-subspace-analysis.org}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage

\begin{appendices}

\section{Measuring the Error of SSA}
\label{app:error_measure}

In order to assess the accuracy of the solution found by SSA when the true mixing matrix $A$ 
is known, we need to adopt an error measure. Since only the non-stationary subspace (spanned 
by the columns of $A^\n$) is identifiable, we measure the deviation between the true and the
estimated \n-space. To that end, we define a \textit{subspace error} based on the 
\textit{principle angles} between two subspaces. Let $U$ and $V$ be two linear subspaces of the 
vector space $\mathcal{V}$ with $\dim U \leq \dim V$. The first principle angle $\theta_1$ is 
defined as the smallest angle between any two vectors $u \in U$ and $v \in V$, 
\begin{align*}
	\theta_1 = \min \left. \left\{ \frac{ u^\top v }{ \| u \| \| v \| } \right| u \in U, v \in V \right\} = \angle(u_1, v_1),
\end{align*}
where the vectors $u_1$ and $v_1$ that minimize the angle are called the principle vectors.
The remaining principle angles $\theta_2, \ldots, \theta_{\dim U}$ are found recursively in the orthogonal 
complement of the previous principle vectors, 
\begin{align*}
	\theta_{k+1} = \min \left. \left\{ \frac{ u^\top v }{ \| u \| \| v \| } \right| u \in U, u \perp u_1, \ldots, u_k , 
			v \in V, v \perp v_1, \ldots, v_k \right\} . 
\end{align*}
Thus the principle vectors in each subspace are mutually orthogonal. If a principle vector $\theta_k$ is zero 
then $U$ and $V$ share a common subspace and $u_k,v_k \in U \cap V$. Hence the dimension of the intersection
of $U$ and $V$ is equivalent to the number of zero principle angles. The principle angles and vectors
can be found using the singular value decomposition (SVD). Let the columns of the matrices $U'$ and $V'$ be 
orthonormal bases for the spaces $U$ and $V$ respectively. From the singular value decomposition 
$\hat{U} \Sigma \hat{V}^\top = (U')^\top V'$ we obtain the principle angles from the singular values, 
$\cos \theta_k = \Sigma_{kk}$ and the principle vectors are the columns of $\hat{U}$ and $\hat{V}$. 

In order to quantify the difference between the true and the estimated stationary subspace 
(spanned by the columns of $\hat{A}^\n$), we define the subspace error given the principle 
angles $\theta_1, \ldots, \theta_{D-d}$ as 
\begin{align*}
	\mathcal{E}(\hat{A}^\n , A^\n ) = \frac{1}{D-d} \sum_{i=1}^{D-d} \sin^2 (\theta_i) .
\end{align*}
This error is zero when the true subspaces are identical and one if they are orthogonal to 
each other. The subspace error can be interpreted in terms of the sources. It is the 
percentage of the signal power which a non-stationary sources loses if it is projected 
from the true onto the estimated non-stationary sources. Conversely, for the estimated stationary
sources $\hat{s}^\n(t) = \hat{P}^\s x(t)$ this means that $\mathcal{E}(\hat{A}^\n , A^\n )$ 
is the percentage of non-stationary signal power that they contain. 

The SSA Toolbox comes with a Matlab function \texttt{subspace\_error} that computes the subspace
error between two subspaces spanned by the columns of two matrices. 

\end{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\bibliographystyle{plain}
\bibliography{ssa.bib}

\end{document}
